--- amarok/amarok/src/engine/helix/helix-sp/helix-include/common/include/atomicbase.h.orig	2005-11-03 22:22:27.000000000 +0100
+++ amarok/amarok/src/engine/helix/helix-sp/helix-include/common/include/atomicbase.h	2005-11-03 23:14:46.000000000 +0100
@@ -179,7 +179,7 @@
 #elif defined (__sparc__) && defined (__GNUC__)
 
 /* Increment by 1 */
-inline void
+static inline void
 HXAtomicIncUINT32(UINT32* pNum)
 {
     __asm__ __volatile__(\
@@ -200,7 +200,7 @@
 }
 
 /* Decrement by 1 */
-inline void
+static inline void
 HXAtomicDecUINT32(UINT32* pNum)
 {
     __asm__ __volatile__(
@@ -221,7 +221,7 @@
 }
 
 /* Increment by 1 and return new value */
-inline UINT32
+static inline UINT32
 HXAtomicIncRetUINT32(UINT32* pNum)
 {
     volatile UINT32 ulRet;
@@ -245,7 +245,7 @@
 }
 
 /* Decrement by 1 and return new value */
-inline UINT32
+static inline UINT32
 HXAtomicDecRetUINT32(UINT32* pNum)
 {   volatile UINT32 ulRet;
     __asm__ __volatile__(
@@ -268,7 +268,7 @@
 }
 
 /* Add n */
-inline void
+static inline void
 HXAtomicAddUINT32(UINT32* pNum, UINT32 ulNum)
 {
     __asm__ __volatile__(
@@ -290,7 +290,7 @@
 }
 
 /* Subtract n */
-inline void
+static inline void
 HXAtomicSubUINT32(UINT32* pNum, UINT32 ulNum)
 {
     __asm__ __volatile__(
@@ -312,7 +312,7 @@
 }
 
 /* Add n and return new value */
-inline UINT32
+static inline UINT32
 HXAtomicAddRetUINT32(UINT32* pNum, UINT32 ulNum)
 {
     volatile UINT32 ulRet; \
@@ -337,7 +337,7 @@
 }
 
 /* Subtract n and return new value */
-inline UINT32
+static inline UINT32
 HXAtomicSubRetUINT32(UINT32* pNum, UINT32 ulNum)
 {   volatile UINT32 ulRet;
     __asm__ __volatile__(
@@ -360,14 +360,14 @@
         return ulRet;
 }
 
-inline void HXAtomicIncINT32(INT32* p)              { HXAtomicIncUINT32((UINT32*)p); }
-inline void HXAtomicDecINT32(INT32* p)              { HXAtomicDecUINT32((UINT32*)p); }
-inline void HXAtomicAddINT32(INT32* p, INT32 n)     { HXAtomicAddUINT32((UINT32*)p, (UINT32)n); }
-inline void HXAtomicSubINT32(INT32* p, INT32 n)     { HXAtomicSubUINT32((UINT32*)p, (UINT32)n); }
-inline INT32 HXAtomicIncRetINT32(INT32* p)          { return HXAtomicIncRetUINT32((UINT32*)p); }
-inline INT32 HXAtomicDecRetINT32(INT32* p)          { return HXAtomicDecRetUINT32((UINT32*)p); }
-inline INT32 HXAtomicAddRetINT32(INT32* p, INT32 n) { return HXAtomicAddRetUINT32((UINT32*)p, (UINT32)n); }
-inline INT32 HXAtomicSubRetINT32(INT32* p, INT32 n) { return HXAtomicSubRetUINT32((UINT32*)p, (UINT32)n); }
+static inline void HXAtomicIncINT32(INT32* p)              { HXAtomicIncUINT32((UINT32*)p); }
+static inline void HXAtomicDecINT32(INT32* p)              { HXAtomicDecUINT32((UINT32*)p); }
+static inline void HXAtomicAddINT32(INT32* p, INT32 n)     { HXAtomicAddUINT32((UINT32*)p, (UINT32)n); }
+static inline void HXAtomicSubINT32(INT32* p, INT32 n)     { HXAtomicSubUINT32((UINT32*)p, (UINT32)n); }
+static inline INT32 HXAtomicIncRetINT32(INT32* p)          { return HXAtomicIncRetUINT32((UINT32*)p); }
+static inline INT32 HXAtomicDecRetINT32(INT32* p)          { return HXAtomicDecRetUINT32((UINT32*)p); }
+static inline INT32 HXAtomicAddRetINT32(INT32* p, INT32 n) { return HXAtomicAddRetUINT32((UINT32*)p, (UINT32)n); }
+static inline INT32 HXAtomicSubRetINT32(INT32* p, INT32 n) { return HXAtomicSubRetUINT32((UINT32*)p, (UINT32)n); }
 
 
 
@@ -547,7 +547,7 @@
 #elif defined(__GNUC__) && !defined(_OPENBSD) && \
       (__GNUC__>2 || (__GNUC__==2 && __GNUC_MINOR__>=95)) && \
       ( defined (__i486__) || defined (__i586__) || defined (__i686__) || \
-        defined (__pentium__) || defined (__pentiumpro__))
+        defined (__pentium__) || defined (__pentiumpro__) || defined (__pentium4__) || defined (__athlon__))
 
 /* Increment by 1 */
 static __inline__ void
@@ -855,6 +855,114 @@
  */
 #elif defined (__alpha)
 
+#  ifdef __GNUC__
+
+/* Increment by 1 and return new value */
+static inline INT32
+HXAtomicIncRetINT32(INT32* pNum)
+{
+    asm volatile (
+        "10:     ldl_l   $1, %0\n"          // Load-lock value into a register
+        "        addl    $1, 1, $1\n"       // Increment value
+        "        stl_c   $1, %0\n"          // Save new value into *pNum
+        "        beq     $1, 10b\n"         // Retry if sequence failed
+        : "=m" (*pNum) : "m" (*pNum) : "$1");
+    return *pNum;
+}
+
+/* Decrement by 1 and return new value */
+static inline INT32
+HXAtomicDecRetINT32(INT32* pNum)
+{
+    asm volatile (
+        "10:     ldl_l   $1, %0\n"          // Load-lock value into a register
+        "        subl    $1, 1, $1\n"       // Decrement value
+        "        stl_c   $1, %0\n"          // Save new value into *pNum
+        "        beq     $1, 10b\n"         // Retry if sequence failed
+        : "=m" (*pNum) : "m" (*pNum) : "$1");
+    return *pNum;
+}
+
+/* Add n and return new value */
+static inline INT32
+HXAtomicAddRetINT32(INT32* pNum, INT32 n)
+{
+    asm volatile (
+        "10:     ldl_l   $1, %0\n"          // Load-lock value into a register
+        "        addl    $1, %1, $1\n"      // Add n to value
+        "        stl_c   $1, %0\n"          // Save new value into *pNum
+        "        beq     $1, 10b\n"         // Retry if sequence failed
+        : "=m" (*pNum) : "r" (n), "m" (*pNum) : "$1");
+    return *pNum;
+}
+
+/* Subtract n and return new value */
+static inline INT32
+HXAtomicSubRetINT32(INT32* pNum, INT32 n)
+{
+    asm volatile (
+        "10:     ldl_l   $1, %0\n"          // Load-lock value into a register
+        "        subl    $1, %1, $1\n"      // Subtract n from value
+        "        stl_c   $1, %0\n"          // Save new value into *pNum
+        "        beq     $1, 10b\n"         // Retry if sequence failed
+        : "=m" (*pNum) : "r" (n), "m" (*pNum) : "$1");
+    return *pNum;
+}
+
+/* Increment by 1 and return new value */
+static inline UINT32
+HXAtomicIncRetUINT32(UINT32* pNum)
+{
+    asm volatile (
+        "10:     ldl_l   $1, %0\n"          // Load-lock value into a register
+        "        addl    $1, 1, $1\n"       // Increment value
+        "        stl_c   $1, %0\n"          // Save new value into *pNum
+        "        beq     $1, 10b\n"         // Retry if sequence failed
+        : "=m" (*pNum) : "m" (*pNum) : "$1");
+    return *pNum;
+}
+
+/* Decrement by 1 and return new value */
+static inline UINT32
+HXAtomicDecRetUINT32(UINT32* pNum)
+{
+    asm volatile (
+        "10:     ldl_l   $1, %0\n"          // Load-lock value into a register
+        "        subl    $1, 1, $1\n"       // Decrement value
+        "        stl_c   $1, %0\n"          // Save new value into *pNum
+        "        beq     $1, 10b\n"         // Retry if sequence failed
+        : "=m" (*pNum) : "m" (*pNum) : "$1");
+    return *pNum;
+}
+
+/* Add n and return new value */
+static inline UINT32
+HXAtomicAddRetUINT32(UINT32* pNum, UINT32 n)
+{
+    asm volatile (
+        "10:     ldl_l   $1, %0\n"          // Load-lock value into a register
+        "        addl    $1, %1, $1\n"      // Add n to value
+        "        stl_c   $1, %0\n"          // Save new value into *pNum
+        "        beq     $1, 10b\n"         // Retry if sequence failed
+        : "=m" (*pNum) : "r" (n), "m" (*pNum) : "$1");
+    return *pNum;
+}
+
+/* Subtract n and return new value */
+static inline UINT32
+HXAtomicSubRetUINT32(UINT32* pNum, UINT32 n)
+{
+    asm volatile (
+        "10:     ldl_l   $1, %0\n"          // Load-lock value into a register
+        "        subl    $1, %1, $1\n"      // Subtract n from value
+        "        stl_c   $1, %0\n"          // Save new value into *pNum
+        "        beq     $1, 10b\n"         // Retry if sequence failed
+        : "=m" (*pNum) : "r" (n), "m" (*pNum) : "$1");
+    return *pNum;
+}
+
+#  else
+
 #include <c_asm.h>
 
 /* Increment by 1 and return new value */
@@ -961,6 +1067,8 @@
         , pNum, n);
 }
 
+#  endif
+
 #define HXAtomicIncINT32(p)    HXAtomicIncRetINT32((p))
 #define HXAtomicDecINT32(p)    HXAtomicDecRetINT32((p))
 #define HXAtomicAddINT32(p,n)  HXAtomicAddRetINT32((p),(n))
